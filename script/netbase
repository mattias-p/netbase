#!/usr/bin/env perl
use strict;
use warnings;

use Const::Fast;
use DateTime;
use File::Slurp qw( read_file write_file );
use Getopt::Long qw( GetOptionsFromArray );
use Netbase qw( ip proto name question rrtype :proto );
use Pod::Usage qw( pod2usage );

const my %ALL_COMMANDS => (
    query => \&do_query,
    dump  => \&do_dump,
    list  => \&do_list,
);

sub main {
    my @args = @_;

    my $opt_help;
    my $opt_man;

    Getopt::Long::Configure qw(
      posix_default
      permute
      bundling
      pass_through
    );
    GetOptionsFromArray(
        \@args,
        "h|help" => \$opt_help,
        "man"    => \$opt_man,
    ) or pod2usage( -verbose => 0 );

    my $cmd_name = shift @args;
    my $cmd_sub  = (
        exists $ALL_COMMANDS{$cmd_name}
        ? $ALL_COMMANDS{$cmd_name}
        : usage_err( "Unrecognized command" )
    ) if defined $cmd_name;

    do_help( $cmd_name )
      if $opt_help;
    pod2usage( -verbose => 2 )
      if $opt_man;

    usage_err( "No command given" )
      if !defined $cmd_sub;

    $cmd_sub->( @args );

    return;
}

use Data::Dumper;

sub do_query {
    my @args = @_;

    # Parse mode and config options
    my $opt_read;
    my $opt_write;
    my $opt_update;
    my $opt_network;
    my $opt_qtype;
    my $opt_qname;
    my $opt_timeout = 5;
    my $opt_retry   = 3;
    my $opt_retrans = 1;
    Getopt::Long::Configure qw( no_pass_through );
    GetOptionsFromArray(
        \@args,
        "n|network"  => \$opt_network,
        "r|read=s"   => \$opt_read,
        "w|write=s"  => \$opt_write,
        "u|update=s" => \$opt_update,
        "timeout=f"  => \$opt_timeout,
        "retry=i"    => \$opt_retry,
        "retrans=f"  => \$opt_retrans,
        "q|qname=s"  => \$opt_qname,
        "t|qtype=s"  => \$opt_qtype,
    ) or usage_err( "Error in command line arguments", "query" );

    if ( defined $opt_update ) {
        usage_err( "Must not specify both --update and --read", "query" )
          if defined $opt_read;

        usage_err( "Must not specify both --update and --write", "query" )
          if defined $opt_write;

        $opt_read  = $opt_update;
        $opt_write = $opt_update;
    }

    if ( defined $opt_write ) {
        $opt_network = 1;
    }

    usage_err( "Must specify at least one of --network, --read, --write or --update", "query" )
      if !defined $opt_network && !defined $opt_read;

    usage_err( "Value out of range for --timeout", "query" )
      if $opt_timeout < 0 || $opt_timeout > 1000;

    usage_err( "Value out of range for --retry", "query" )
      if $opt_retry < 1 || $opt_retry > 1000;

    usage_err( "Value out of range for --retrans", "query" )
      if $opt_retrans < 0 || $opt_retrans > 1000;

    # Parse request options
    my $opt_proto   = $PROTO_UDP;
    my $opt_recurse = 0;
    my $opt_dnssec;
    my $opt_edns_version;
    my $opt_edns_opt;
    Getopt::Long::Configure qw(
      prefix=+
      no_bundling
    );
    GetOptionsFromArray(
        \@args,
        'udp+'       => sub { $opt_proto = $PROTO_UDP },
        'tcp+'       => sub { $opt_proto = $PROTO_TCP },
        'recurse!'   => \$opt_recurse,
        'noedns+'    => sub { $opt_edns_version = undef },
        'edns=i'     => \$opt_edns_version,
        'ednsopt=s'  => \$opt_edns_opt,
        'noednsopt+' => sub { $opt_edns_opt = undef },
        'dnssec!'    => \$opt_dnssec,
    ) or usage_err( "Error in command line arguments", "query" );

    my $edns_opt_code;
    my $edns_opt_value;
    if ( defined $opt_edns_opt ) {
        my ( $code, $value ) = split /:/, $opt_edns_opt, 2;
        $code =~ /^([0-9]+)$/    #
          or usage_err( "Invalid ednsopt code given", "query" );
        $edns_opt_code = $1;

        if ( defined $value ) {
            $value =~ /^((:?[0-9a-f]{2})+)$/i    #
              or usage_err( "Invalid ednsopt value given", "query" );
            $edns_opt_value = [ map ord, split //, pack "H*", $1 ];
        }
        else {
            $edns_opt_value = "";
        }
    }

    if ( $opt_edns_version || $opt_dnssec || $edns_opt_code ) {
        $opt_edns_version //= 0;
        $opt_dnssec       //= 0;
    }

    if ( defined $opt_edns_version ) {
        usage_err( "EDNS version out of range", "query" )
          if $opt_edns_version < 0 || $opt_edns_version > 255;

        usage_err( "EDNS option code out of range", "query" )
          if defined $edns_opt_code && ( $edns_opt_code < 1 || $edns_opt_code > 65535 );
    }
    $edns_opt_code //= 0;

    # Parse qname, qtype and server
    my $opt_ns;
    for my $arg ( @args ) {
        if ( $arg =~ /^@/ ) {
            usage_err( "Multiple server addresses given", "query" )
              if defined $opt_ns;
            $opt_ns = $arg;
        }
        elsif ( rrtype( $arg ) ) {
            usage_err( "Multiple qtype values given", "query" )
              if defined $opt_qtype;
            $opt_qtype = $arg;
        }
        elsif ( name( $arg ) ) {
            usage_err( "Multiple qname values given", "query" )
              if defined $opt_qname;
            $opt_qname = $arg;
        }
        else {
            usage_err( "Unrecognized argument given: $arg", "query" );
        }
    }

    my $qname = name(
       $opt_qname // usage_err( "No qname given", "query" )    #
    ) // usage_err( "Invalid qname given", "query" );

    my $qtype = name(
        $opt_qtype // usage_err( "No qtype given", "query" )    #
    ) // usage_err( "Invalid qtype given", "query" );

    my $ns = parse_ns(
        $opt_ns // usage_err( "No server given", "query" )    #
    ) // usage_err( "Invalid name server address given", "query" );

    # Construct question
    my $question = question(
        $qname, $qtype,
        {
            proto             => $opt_proto,
            recursion_desired => $opt_recurse,
        }
    );
    if ( defined $opt_edns_version ) {
        $question->set_edns( $opt_edns_version, $opt_dnssec, $edns_opt_code, $edns_opt_value );
    }

    # Initialize cache
    my $cache = init_cache( $opt_read );

    # Initialize networking
    my $net;
    if ( defined $opt_network ) {
        $net = Netbase::Net->new(
            timeout => $opt_timeout,
            retry   => $opt_retry,
            retrans => $opt_retrans,
        );
    }

    # Perform lookup
    my @outcome = $cache->lookup( $net, $question, $ns );
    show_all_attempts( $cache, $question, $ns, @outcome );

    # Save cache
    if ( $opt_write ) {
        write_file $opt_write, $cache->to_bytes();
    }

    return;
}

sub do_list {
    my @args = @_;

    Getopt::Long::Configure qw( no_pass_through );
    GetOptionsFromArray(
        \@args,
    ) or usage_err( "Error in command line arguments", "list" );

    my $arg_file = shift( @args )    #
      // usage_err( "No cache file given", "list" );

    if ( @args ) {
        usage_err( "Extra arguments given", "dump" );
    }

    my $cache = init_cache( $arg_file );

    $cache->for_each_request(
        sub {
            my ( $ns, $question ) = @_;
            print "$question \@$ns\n";
        }
    );

    return;
}

sub do_dump {
    my @args = @_;

    Getopt::Long::Configure qw( no_pass_through );
    GetOptionsFromArray(
        \@args,
    ) or usage_err( "Error in command line arguments", "dump" );

    my $arg_file = shift( @args )    #
      // usage_err( "No cache file given", "dump" );

    if ( @args ) {
        usage_err( "Extra arguments given", "dump" );
    }

    my $cache = init_cache( $arg_file );

    my @queries;
    $cache->for_each_request(
        sub {
            my ( $ns, $question ) = @_;
            my ( $message, $err_kind, $start, $duration, $size, $err_msg ) = $cache->lookup( undef, $question, $ns );
            push @queries, [ $question, $ns, $message, $err_kind, $start, $duration, $size, $err_msg ];
        }
    );

    my $first = 1;
    for my $entry ( sort { $a->[4] <=> $b->[4] } @queries ) {
        print "\n\n"
          if !$first;
        $first = 0;

        show_all_attempts( $cache, @$entry );
    }

    return;
}

sub init_cache {
    my ( $file ) = @_;
    if ( $file ) {
        my $contents = read_file( $file );
        return Netbase::Cache->from_bytes( $contents );
    }
    else {
        return Netbase::Cache->new();
    }
}

sub parse_ns {
    my ( $value ) = @_;
    if ( $value =~ /^@(.*)$/ ) {
        return ip( $1 );
    }
    else {
        return;
    }
}

sub show_all_attempts {
    my ( $cache, $question, $ns, $message, $err_kind, $start, $duration, $size, $err_msg ) = @_;

    my @failures;
    $cache->for_each_retry(
        $question,
        $ns,
        sub {
            my ( $start, $duration, $err_kind ) = @_;
            push @failures, [ $question, $ns, undef, $err_kind, $start, $duration, 0, undef ];
        }
    );

    for my $failure ( @failures ) {
        show_outcome( @$failure );
        print "\n\n";
    }
    show_outcome( $question, $ns, $message, $err_kind, $start, $duration, $size, $err_msg );

    return;
}

sub show_outcome {
    my ( $question, $ns, $message, $err_kind, $start, $duration, $size, $err_msg ) = @_;
    print "; <<>> netbase <<>> $question \@$ns\n";

    my $dt = DateTime->from_epoch( epoch => $start / 1_000.0 );
    if ( $message ) {
        print ";; Got answer:\n";
        print $message;
        print "\n";
        printf ";; Response size: %s bytes\n", $size;
    }
    elsif ( $err_kind ) {
        if ( $err_msg ) {
            printf ";; %s: %s\n", $err_kind, $err_msg;
        }
        else {
            printf ";; %s\n", $err_kind;
        }
        print "\n";
    }
    else {
        print ";; NOT IN CACHE\n";

        return;
    }

    printf ";; Name server: %s#53\n",          $ns;
    printf ";; Request sent: %s\n",         $dt->strftime( "%F %T.%3N" );
    printf ";; Response time: %s msec\n", $duration;

    return;
}

sub do_help {
    my ( $cmd_name ) = @_;

    if ( defined $cmd_name ) {
        pod2usage( -verbose => 99, -sections => "COMMAND netbase $cmd_name" );
    }
    else {
        pod2usage( -verbose => 99, -sections => "NAME|SYNOPSIS|OPTIONS|COMMANDS|DESCRIPTION" );
    }

    return;
}

sub usage_err {
    my ( $message, $cmd_name ) = @_;

    if ( defined $cmd_name ) {
        pod2usage( -msg => "netbase: $message", -verbose => 99, -sections => "COMMAND netbase $cmd_name/USAGE" );
    }
    else {
        pod2usage( "netbase: $message" );
    }

    return;
}

if ( __PACKAGE__ eq 'main' ) {
    main( @ARGV );
}

=head1 NAME

netbase - DNS cache lookup utility

=head1 SYNOPSIS

netbase --help

netbase --help COMMAND

netbase --man

netbase COMMAND [command_params]

=head1 OPTIONS

=over 4

=item B<--help>

Print a brief help message and exit.
If no command is given the help message concerns B<netbase> itself.
If a command is given the help message concerns that command.

=item B<--man>

Print the full manual page and exit.

=back

=head1 COMMANDS

=over 4

=item B<query>

Make a single query.

=item B<list>

List all requests in the cache.

=item B<dump>

Dump all requests in the cache, along with their outcomes.

=back

=head1 COMMAND netbase query

=head2 NAME

netbase query - Perform a single lookup

=head2 USAGE

netbase query -n [-r FILE] [-q] NAME [-t] TYPE SERVER [query options]

netbase query -r FILE [-w FILE] [-q] NAME [-t] TYPE SERVER [query options]

netbase query -w FILE [-q] NAME [-t] TYPE SERVER [query options]

netbase query -u FILE [-q] NAME [-t] TYPE SERVER [query options]

=head2 MODES

=over 4

=item B<-n>, B<--network>

If the given request is not answered in the cache, send the request over the
network and record the outcome in the cache.

=item B<-r FILE>, B<--read FILE>

Initialize the cache from the given FILE.
Must not be combined B<--update>.
By default the cache is initialized to be empty.

=item B<-w FILE>, B<--write FILE>

After the lookup, save the cache to the given FILE.
By default any changes to the cache are dropped.
Implicitly sets B<--network>.
Must not be combined B<--update>.

=item B<-u FILE>, B<--update FILE>

Short for B<--read FILE --write FILE>.
Must not be combined with B<--read> nor with B<--write>.

=back

=head2 CONFIG ARGUMENTS

=over 4

=item B<--timeout DURATION>

Seconds to wait for a response without giving up.
A floating point number with millisecond precision.
Default is 5.

=item B<--retry COUNT>

Number of times to try a query before giving up.
Default is 3.

=item B<--retrans DURATION>

Seconds of extra delay before retrying a request.
A floating point number with millisecond precision.
Default is 1.

=back

=head2 QUERY ARGUMENTS

=over 4

=item B<SERVER>

The syntax for a SERVER is an at-sign (@) immediately followed by an IP address.

=item B<TYPE>

Short for B<--qtype TYPE>.

=item B<NAME>

Short for B<--qname NAME>.

B<Note>: When using this syntax NAME must not be a valid TYPE or it will be interpreted
as a TYPE.

=item B<-q NAME>, B<--qname NAME>

The qname to ask for in the request.

=item B<-t TYPE>, B<--qtype TYPE>

The qtype to ask for in the request.

=back

=head2 QUERY OPTIONS

=over 4

=item B<+udp>, B<+tcp>

Select transport protocol.
Default is C<+udp>.

=item B<+recurse>, B<+norecurse>

Enable/disable the RD flag in the request.
Default is C<+norecurse>.

=item B<+edns VERSION>, B<+noedns>

Enable/disable EDNS and set its version in the request.
Default is C<+noedns> if all other EDNS options are disabled.
Default is C<+edns 0> if at least one EDNS option is enabled.

=item B<+dnssec>, B<+nodnssec>

Enable/disable the DO flag in the EDNS header of the request.
Default is C<+noednssec>.

=item B<+ednsopt=CODE>, B<+noednsopt>

Enable/disable the adding of the given option code to the EDNS header of the
request.
Default is C<+noednsopt>.

=back

=head1 COMMAND netbase list

=head2 NAME

netbase list - List all requests in the cache.

=head2 USAGE

netbase list FILE

=head2 ARGUMENTS

=over 4

=item B<FILE>

Initialize the cache from the given FILE.

=back

=head1 COMMAND netbase dump

=head2 NAME

netbase dump - Dump all requests in the cache, along with their outcomes.

=head2 USAGE

netbase dump FILE

=head2 ARGUMENTS

=over 4

=item B<FILE>

Initialize the cache from the given FILE.

=back

=head1 DESCRIPTION

Reads and writes DNS cache files and makes single DNS queries.

=cut
