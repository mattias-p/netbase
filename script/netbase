#!/usr/bin/env perl
use strict;
use warnings;

use Const::Fast;
use DateTime;
use File::Slurp qw( read_file write_file );
use Getopt::Long qw( GetOptionsFromArray );
use Netbase qw( ip proto name question rrtype :proto );
use Pod::Usage qw( pod2usage );

const my %ALL_COMMANDS => (
    query => \&do_query,
    dump  => \&do_dump,
    list  => \&do_list,
);

sub main {
    my @args = @_;

    my $opt_help;
    my $opt_man;

    Getopt::Long::Configure qw( posix_default bundling require_order );
    GetOptionsFromArray(
        \@args,
        "h|help" => \$opt_help,
        "man"    => \$opt_man,
    ) or pod2usage( -verbose => 0 );
    Getopt::Long::Configure qw( no_require_order );

    my $cmd_name = shift @args;
    my $cmd_sub  = (
        exists $ALL_COMMANDS{$cmd_name}
        ? $ALL_COMMANDS{$cmd_name}
        : usage_err( "Unrecognized command" )
    ) if defined $cmd_name;

    do_help( $cmd_name )
      if $opt_help;
    pod2usage( -verbose => 2 )
      if $opt_man;

    usage_err( "No command specified" )
      if !defined $cmd_sub;

    $cmd_sub->( @args );

    return;
}

sub do_query {
    my @args = @_;

    my $opt_help;
    my $opt_man;
    my $opt_read;
    my $opt_write;
    my $opt_update;
    my $opt_network;
    my $opt_qname;
    my $opt_qtype;
    my $opt_ns;
    my $opt_proto   = $PROTO_UDP;
    my $opt_recurse = 0;
    my %plus_opts   = (
        udp       => sub { $opt_proto   = $PROTO_UDP },
        tcp       => sub { $opt_proto   = $PROTO_TCP },
        recurse   => sub { $opt_recurse = 1 },
        norecurse => sub { $opt_recurse = 0 },
    );

    GetOptionsFromArray(
        \@args,
        "h|help"     => \$opt_help,
        "man"        => \$opt_man,
        "n|network"  => \$opt_network,
        "r|read=s"   => \$opt_read,
        "w|write=s"  => \$opt_write,
        "u|update=s" => \$opt_update,
        "q|qname=s"  => \$opt_qname,
        "t|qtype=s"  => \$opt_qtype,
        "<>"         => sub {
            my ( $value ) = @_;
            if ( rrtype( $value ) ) {
                $opt_qtype = $value;
            }
            elsif ( name( $value ) ) {
                $opt_qname = $value;
            }
            elsif ( parse_ns( $value ) ) {
                $opt_ns = $value;
            }
            elsif ( ( $value =~ /^\+(.*)$/ ) && ( my $callback = $plus_opts{$1} ) ) {
                $callback->();
            }
            else {
                usage_err( "Invalid argument: $value", "query" );
            }
        },
    ) or usage_err( "Error in command line arguments", "query" );
    $opt_proto //= 'UDP';

    do_help( "query" )
      if $opt_help;
    pod2usage( -verbose => 2 )
      if $opt_man;

    usage_err( "No qname specified", "query" )
      if !defined $opt_qname;

    usage_err( "No qtype specified", "query" )
      if !defined $opt_qtype;

    usage_err( "No server specified", "query" )
      if !defined $opt_ns;

    if ( defined $opt_update ) {
        usage_err( "Must not specify both --update and --read", "query" )
          if defined $opt_read;

        usage_err( "Must not specify both --update and --write", "query" )
          if defined $opt_write;

        $opt_read  = $opt_update;
        $opt_write = $opt_update;
    }

    if ( defined $opt_write ) {
        $opt_network = 1;
    }

    usage_err( "Must specify at least one of --network, --read, --write or --update", "query" )
      if !defined $opt_network && !defined $opt_read;

    my $qname = name( $opt_qname )   // usage_err( "Invalid qname given",               "query" );
    my $qtype = rrtype( $opt_qtype ) // usage_err( "Invalid qtype given",               "query" );
    my $ns    = parse_ns( $opt_ns )  // usage_err( "Invalid name server address given", "query" );
    my $proto = proto( $opt_proto )  // usage_err( "invalid proto given",               "query" );

    my $cache = init_cache( $opt_read );
    my $net;
    if ( defined $opt_network ) {
        $net = Netbase::Net->new( 3, 1 );
    }

    my $question = question(
        $qname, $qtype,
        {
            proto             => $proto,
            recursion_desired => $opt_recurse,
        }
    );

    show_all_attempts( $cache, $question, $ns, $cache->lookup( $net, $question, $ns ) );

    if ( $opt_write ) {
        write_file $opt_write, $cache->to_bytes();
    }

    return;
}

sub do_list {
    my @args = @_;

    my $opt_help;
    my $opt_man;
    GetOptionsFromArray(
        \@args,
        "h|help" => \$opt_help,
        "man"    => \$opt_man,
    ) or usage_err( "Error in command line arguments", "list" );

    do_help( "list" )
      if $opt_help;
    pod2usage( -verbose => 2 )
      if $opt_man;

    my $arg_file = shift( @args )    #
      // usage_err( "No cache file specified", "list" );

    if ( @args ) {
        usage_err( "Extra arguments specified", "dump" );
    }

    my $cache = init_cache( $arg_file );

    $cache->for_each_request(
        sub {
            my ( $ns, $question ) = @_;
            print "$question \@$ns\n";
        }
    );

    return;
}

sub do_dump {
    my @args = @_;

    my $opt_help;
    my $opt_man;
    GetOptionsFromArray(
        \@args,
        "h|help" => \$opt_help,
        "man"    => \$opt_man,
    ) or usage_err( "Error in command line arguments", "dump" );

    do_help( "dump" )
      if $opt_help;
    pod2usage( -verbose => 2 )
      if $opt_man;

    my $arg_file = shift( @args )    #
      // usage_err( "No cache file specified", "dump" );

    if ( @args ) {
        usage_err( "Extra arguments specified", "dump" );
    }

    my $cache = init_cache( $arg_file );

    my @queries;
    $cache->for_each_request(
        sub {
            my ( $ns, $question ) = @_;
            my ( $message, $err_kind, $start, $duration, $size, $err_msg ) = $cache->lookup( undef, $question, $ns );
            push @queries, [ $question, $ns, $message, $err_kind, $start, $duration, $size, $err_msg ];
        }
    );

    my $first = 1;
    for my $entry ( sort { $a->[4] <=> $b->[4] } @queries ) {
        print "\n\n"
          if !$first;
        $first = 0;

        show_all_attempts( $cache, @$entry );
    }

    return;
}

sub init_cache {
    my ( $file ) = @_;
    if ( $file ) {
        my $contents = read_file( $file );
        return Netbase::Cache->from_bytes( $contents );
    }
    else {
        return Netbase::Cache->new();
    }
}

sub parse_ns {
    my ( $value ) = @_;
    if ( $value =~ /^@(.*)$/ ) {
        return ip( $1 );
    }
    else {
        return;
    }
}

sub show_all_attempts {
    my ( $cache, $question, $ns, $message, $err_kind, $start, $duration, $size, $err_msg ) = @_;

    my @failures;
    $cache->for_each_retry(
        $question,
        $ns,
        sub {
            my ( $start, $duration, $err_kind ) = @_;
            push @failures, [ $question, $ns, undef, $err_kind, $start, $duration, 0, undef ];
        }
    );

    for my $failure ( @failures ) {
        show_outcome( @$failure );
        print "\n\n"
    }
    show_outcome( $question, $ns, $message, $err_kind, $start, $duration, $size, $err_msg );

    return;
}

sub show_outcome {
    my ( $question, $ns, $message, $err_kind, $start, $duration, $size, $err_msg ) = @_;
    print "; <<>> netbase <<>> $question \@$ns\n";

    my $dt = DateTime->from_epoch( epoch => $start / 1_000.0 );
    if ( $message ) {
        print ";; Got answer:\n";
        print $message;
        print "\n";
        printf ";; MSG SIZE  rcvd: %s\n", $size;
    }
    elsif ( $err_kind ) {
        if ( $err_msg ) {
            printf ";; %s: %s\n", $err_kind, $err_msg;
        }
        else {
            printf ";; %s\n", $err_kind;
        }
        print "\n";
    }
    else {
        print ";; no response\n";
        print "\n";
    }
    printf ";; SERVER: %s#53\n",       $ns;
    printf ";; WHEN: %s\n",            $dt->strftime( "%F %T.%3N" );
    printf ";; Query time: %s msec\n", $duration;

    return;
}

sub do_help {
    my ( $cmd_name ) = @_;

    if ( defined $cmd_name ) {
        pod2usage( -verbose => 99, -sections => "COMMAND netbase $cmd_name" );
    }
    else {
        pod2usage( -verbose => 99, -sections => "NAME|SYNOPSIS|OPTIONS|COMMANDS|DESCRIPTION" );
    }

    return;
}

sub usage_err {
    my ( $message, $cmd_name ) = @_;

    if ( defined $cmd_name ) {
        pod2usage( -msg => "netbase: $message", -verbose => 99, -sections => "COMMAND netbase $cmd_name/USAGE" );
    }
    else {
        pod2usage( "netbase: $message" );
    }

    return;
}

if ( __PACKAGE__ eq 'main' ) {
    main( @ARGV );
}

=head1 NAME

netbase - DNS cache lookup utility

=head1 SYNOPSIS

netbase --help

netbase --help COMMAND

netbase --man

netbase COMMAND [command_params]

=head1 OPTIONS

=over 4

=item B<--help>

Print a brief help message and exit.
If no command is given the help message concerns B<netbase> itself.
If a command is given the help message concerns that command.

=item B<--man>

Print the full manual page and exit.

=back

=head1 COMMANDS

=over 4

=item B<query>

Make a single query.

=item B<list>

List all requests in the cache.

=item B<dump>

Dump all requests in the cache, along with their outcomes.

=back

=head1 COMMAND netbase query

=head2 NAME

netbase query - Perform a single lookup

=head2 USAGE

netbase query -n [-r FILE] [-q] NAME [-t] TYPE SERVER [query options]

netbase query -r FILE [-w FILE] [-q] NAME [-t] TYPE SERVER [query options]

netbase query -w FILE [-q] NAME [-t] TYPE SERVER [query options]

netbase query -u FILE [-q] NAME [-t] TYPE SERVER [query options]

=head2 MODES

=over 4

=item B<-n>, B<--network>

If the given request is not answered in the cache, send the request over the
network and record the outcome in the cache.

=item B<-r FILE>, B<--read FILE>

Initialize the cache from the given FILE.
Must not be combined B<--update>.
By default the cache is initialized to be empty.

=item B<-w FILE>, B<--write FILE>

After the lookup, save the cache to the given FILE.
By default any changes to the cache are dropped.
Implicitly sets B<--network>.
Must not be combined B<--update>.

=item B<-u FILE>, B<--update FILE>

Short for B<--read FILE --write FILE>.
Must not be combined with B<--read> nor with B<--write>.

=back

=head2 QUERY ARGUMENTS

=over 4

=item B<TYPE>

Short for B<--qtype TYPE>.

=item B<NAME>

Short for B<--qname NAME>.

B<Note>: When using this syntax NAME must not be a valid TYPE or it will be interpreted
as a TYPE.

=item B<SERVER>

The syntax for a SERVER is an at-sign (@) immediately followed by an IP address.

=item B<-q NAME>, B<--qname NAME>

The qname to ask for in the request.

=item B<-t TYPE>, B<--qtype TYPE>

The qtype to ask for in the request.

=head2 QUERY OPTIONS

=item B<+udp>, B<+tcp>

Select transport protocol.
Default is C<+udp>.

=item B<+recurse>, B<+norecurse>

Set/unset the RD flag in the request.
Default is C<+norecurse>.

=back

=head1 COMMAND netbase list

=head2 NAME

netbase list - List all requests in the cache.

=head2 USAGE

netbase list FILE

=head2 ARGUMENTS

=over 4

=item B<FILE>

Initialize the cache from the given FILE.

=back

=head1 COMMAND netbase dump

=head2 NAME

netbase dump - Dump all requests in the cache, along with their outcomes.

=head2 USAGE

netbase dump FILE

=head2 ARGUMENTS

=over 4

=item B<FILE>

Initialize the cache from the given FILE.

=back

=head1 DESCRIPTION

Reads and writes DNS cache files and makes single DNS queries.

=cut
